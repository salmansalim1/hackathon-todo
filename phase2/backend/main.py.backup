"""
FastAPI Backend for Todo Application
Phase II: Full-Stack Web Application
"""

from fastapi import FastAPI, HTTPException, Depends, Header
from fastapi.middleware.cors import CORSMiddleware
from sqlmodel import Session, select
from typing import Optional
import jwt
from datetime import datetime, timedelta
import os
from dotenv import load_dotenv

from models import Task, TaskCreate, TaskUpdate, User, UserCreate
from database import engine, create_db_and_tables, get_session

# Load environment variables
load_dotenv()

# Initialize FastAPI app
app = FastAPI(
    title="Todo API",
    description="Phase II - Full-Stack Todo Application with Authentication",
    version="2.0.0"
)

# CORS Configuration
app.add_middleware(
    CORSMiddleware,
    allow_origins=["http://localhost:3000", "https://*.vercel.app"],
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

# JWT Configuration
JWT_SECRET = os.getenv("JWT_SECRET", "your-secret-key")
JWT_ALGORITHM = os.getenv("JWT_ALGORITHM", "HS256")
JWT_EXPIRATION_HOURS = int(os.getenv("JWT_EXPIRATION_HOURS", "168"))


# Startup Event
@app.on_event("startup")
def on_startup():
    """Create database tables on startup"""
    create_db_and_tables()


# Helper Functions
def create_access_token(user_id: str, email: str) -> str:
    """Create JWT access token"""
    expire = datetime.utcnow() + timedelta(hours=JWT_EXPIRATION_HOURS)
    to_encode = {
        "sub": user_id,
        "email": email,
        "exp": expire
    }
    encoded_jwt = jwt.encode(to_encode, JWT_SECRET, algorithm=JWT_ALGORITHM)
    return encoded_jwt


def verify_token(authorization: Optional[str] = Header(None)) -> dict:
    """Verify JWT token from Authorization header"""
    if not authorization:
        raise HTTPException(status_code=401, detail="Missing authorization header")
    
    try:
        # Extract token from "Bearer <token>"
        scheme, token = authorization.split()
        if scheme.lower() != "bearer":
            raise HTTPException(status_code=401, detail="Invalid authentication scheme")
        
        # Decode token
        payload = jwt.decode(token, JWT_SECRET, algorithms=[JWT_ALGORITHM])
        return payload
    except jwt.ExpiredSignatureError:
        raise HTTPException(status_code=401, detail="Token has expired")
    except jwt.InvalidTokenError:
        raise HTTPException(status_code=401, detail="Invalid token")
    except Exception:
        raise HTTPException(status_code=401, detail="Could not validate credentials")


# Health Check
@app.get("/")
def root():
    """Health check endpoint"""
    return {
        "status": "healthy",
        "message": "Todo API Phase II",
        "version": "2.0.0"
    }


@app.get("/health")
def health_check():
    """Detailed health check"""
    return {
        "status": "healthy",
        "database": "connected",
        "timestamp": datetime.utcnow().isoformat()
    }


# Authentication Endpoints
@app.post("/api/auth/signup")
def signup(user_data: UserCreate, session: Session = Depends(get_session)):
    """Create new user account"""
    # Check if user already exists
    statement = select(User).where(User.email == user_data.email)
    existing_user = session.exec(statement).first()
    
    if existing_user:
        raise HTTPException(status_code=400, detail="Email already registered")
    
    # Create new user
    new_user = User(
        email=user_data.email,
        name=user_data.name,
        hashed_password=user_data.password  # In production, hash this!
    )
    
    session.add(new_user)
    session.commit()
    session.refresh(new_user)
    
    # Generate token
    token = create_access_token(new_user.id, new_user.email)
    
    return {
        "user": {
            "id": new_user.id,
            "email": new_user.email,
            "name": new_user.name
        },
        "token": token
    }


@app.post("/api/auth/signin")
def signin(user_data: UserCreate, session: Session = Depends(get_session)):
    """Sign in existing user"""
    # Find user
    statement = select(User).where(User.email == user_data.email)
    user = session.exec(statement).first()
    
    if not user or user.hashed_password != user_data.password:
        raise HTTPException(status_code=401, detail="Invalid credentials")
    
    # Generate token
    token = create_access_token(user.id, user.email)
    
    return {
        "user": {
            "id": user.id,
            "email": user.email,
            "name": user.name
        },
        "token": token
    }


# Task Endpoints (Protected)
@app.get("/api/{user_id}/tasks")
def list_tasks(
    user_id: str,
    status: Optional[str] = "all",
    session: Session = Depends(get_session),
    token_data: dict = Depends(verify_token)
):
    """List all tasks for authenticated user"""
    # Verify user_id matches token
    if token_data["sub"] != user_id:
        raise HTTPException(status_code=403, detail="Not authorized to access this user's tasks")
    
    # Build query
    statement = select(Task).where(Task.user_id == user_id)
    
    # Filter by status if specified
    if status == "completed":
        statement = statement.where(Task.completed == True)
    elif status == "pending":
        statement = statement.where(Task.completed == False)
    
    # Execute query
    tasks = session.exec(statement).all()
    
    return {"tasks": tasks, "count": len(tasks)}


@app.post("/api/{user_id}/tasks")
def create_task(
    user_id: str,
    task_data: TaskCreate,
    session: Session = Depends(get_session),
    token_data: dict = Depends(verify_token)
):
    """Create a new task"""
    # Verify user_id matches token
    if token_data["sub"] != user_id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    # Create task
    new_task = Task(
        user_id=user_id,
        title=task_data.title,
        description=task_data.description,
        completed=False
    )
    
    session.add(new_task)
    session.commit()
    session.refresh(new_task)
    
    return new_task


@app.get("/api/{user_id}/tasks/{task_id}")
def get_task(
    user_id: str,
    task_id: int,
    session: Session = Depends(get_session),
    token_data: dict = Depends(verify_token)
):
    """Get task details"""
    # Verify user_id matches token
    if token_data["sub"] != user_id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    # Find task
    task = session.get(Task, task_id)
    
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    if task.user_id != user_id:
        raise HTTPException(status_code=403, detail="Not authorized to access this task")
    
    return task


@app.put("/api/{user_id}/tasks/{task_id}")
def update_task(
    user_id: str,
    task_id: int,
    task_data: TaskUpdate,
    session: Session = Depends(get_session),
    token_data: dict = Depends(verify_token)
):
    """Update a task"""
    # Verify user_id matches token
    if token_data["sub"] != user_id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    # Find task
    task = session.get(Task, task_id)
    
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    if task.user_id != user_id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    # Update fields
    if task_data.title is not None:
        task.title = task_data.title
    if task_data.description is not None:
        task.description = task_data.description
    if task_data.completed is not None:
        task.completed = task_data.completed
    
    task.updated_at = datetime.utcnow()
    
    session.add(task)
    session.commit()
    session.refresh(task)
    
    return task


@app.delete("/api/{user_id}/tasks/{task_id}")
def delete_task(
    user_id: str,
    task_id: int,
    session: Session = Depends(get_session),
    token_data: dict = Depends(verify_token)
):
    """Delete a task"""
    # Verify user_id matches token
    if token_data["sub"] != user_id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    # Find task
    task = session.get(Task, task_id)
    
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    if task.user_id != user_id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    # Delete task
    session.delete(task)
    session.commit()
    
    return {"message": "Task deleted successfully", "task_id": task_id}


@app.patch("/api/{user_id}/tasks/{task_id}/complete")
def toggle_complete(
    user_id: str,
    task_id: int,
    session: Session = Depends(get_session),
    token_data: dict = Depends(verify_token)
):
    """Toggle task completion status"""
    # Verify user_id matches token
    if token_data["sub"] != user_id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    # Find task
    task = session.get(Task, task_id)
    
    if not task:
        raise HTTPException(status_code=404, detail="Task not found")
    
    if task.user_id != user_id:
        raise HTTPException(status_code=403, detail="Not authorized")
    
    # Toggle completion
    task.completed = not task.completed
    task.updated_at = datetime.utcnow()
    
    session.add(task)
    session.commit()
    session.refresh(task)
    
    return task


if __name__ == "__main__":
    import uvicorn
    uvicorn.run(app, host="0.0.0.0", port=8000)
